<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 8.3.2 (457479)"/><meta name="keywords" content="数据结构"/><meta name="author" content="hatake8607"/><meta name="created" content="2018-12-03 13:54:31 +0000"/><meta name="updated" content="2018-12-15 14:45:28 +0000"/><title>05 数组</title></head><body><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">如何实现随机访问</span></div></li><ul><li><div><span style="font-size: 18px;">数组 (</span><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">Array) </span><span style="font-size: 18px;">是一种线性表数据结构</span></div></li><li><div><span style="font-size: 18px;">它用一组连续的内存空间，来存储一组具有相同类型的数据</span></div></li></ul></ul><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">线性表 —— 数组、队列、链表、栈</span></div></li></ul><div><span style="font-family: &quot;courier new&quot;, courier, monospace;"><img src="05%20%E6%95%B0%E7%BB%84.resources/page1.jpg" height="833" width="1142"/><br/></span></div><div><br clear="none"/></div><div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">非线性表 —— 二叉树、堆、图</span></div></li></ul></div><div><span style="font-family: &quot;courier new&quot;, courier, monospace;"><img src="05%20%E6%95%B0%E7%BB%84.resources/page2.jpg" height="727" width="1142"/><br/></span></div><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">数组的随机访问（地址连续 + 数据类型相同）</span></div></li><ul><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">根据下标访问数组的时间复杂度是 O(1)</span></div></li><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">如果是顺序查找，即使是排序过的，使用二分法，时间复杂度也是 O(logn) </span></div></li></ul></ul><div><span style="font-family: &quot;courier new&quot;, courier, monospace;"><img src="05%20%E6%95%B0%E7%BB%84.resources/page3.jpg" height="580" width="1142"/><br/></span></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">低效的插入和删除</span></div></li></ul><div><br clear="none"/></div><ul><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">插入</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">假设数组长度 n，将新数据插入到数组的第 k 位，则需要将 k ~ n 的数据都顺序的往后挪一位</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">最好时间复杂度：O(1) - 插在最后</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">最坏时间复杂度：O(n) - 插在开头</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">平均时间复杂度：O(1 + 2 + 3 ... + n) / n = O(n)</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">如果数组是无序的，那么直接将新元素放入第 k 位，将原来第 k 位的数据放在最后即可，提高插入效率</span></div></li><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">删除</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">和插入类似，为了连续性，需要移动数据</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">复杂度情况参考插入，是一致的</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">在并不需要保证数组连续性的情况下，可以使用标记为来标记已删除的数据，在数组没有更多空间的时候，再去一次性的删除和数据迁移操作</span></div></li></ul><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">容器能否代替数组（ArrayList等）</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">希望使用基本类型的，可以使用数组</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">大小明确，操作简单，可以使用数组</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">多维数据时，数组更直观点</span></div></li><li><div><span style="font-size: 14px; font-family: &quot;courier new&quot;, courier, monospace;">平时业务开发，使用容器即可，省时省力；如果是和性能特别相关的，则可以考虑使用数组</span></div></li></ul><div><br clear="none"/></div><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px;">大多数语言的数组为什么从 </span><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">0</span><span style="font-size: 24px;"> 开始，而不是从</span><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;"> 1</span><span style="font-size: 24px;"> 开始</span></div></li><ul><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">a[k] 就表示偏移 k 个 type_size 的位置</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">下标从0开始：a[k]_address = base_address + k * type_size</span></div></li><li><div><span style="font-family: &quot;courier new&quot;, courier, monospace;">下标从1开始：a[k]_address = base_address + (k - 1) * type_size —— 多一次剪发运算</span></div></li></ul></ul><div><br clear="none"/></div><ul><li><div><span style="font-size: 24px; font-family: &quot;courier new&quot;;"><span>思考题</span></span></div></li><ul><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">JVM 标记清除垃圾回收算</span></div></li><li><div><span style="font-size: 18px; font-family: &quot;courier new&quot;, courier, monospace;">二位数组的寻址公式</span></div></li></ul></ul><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div></body></html>